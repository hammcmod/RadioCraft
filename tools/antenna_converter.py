"""
Utility script for converting NanoVNA Touchstone .s1p files into the compact JSON
format consumed by RadioCraft at runtime.

Usage
-----
    python tools/antenna_converter.py <input.s1p> <output.json>

The converter enforces the "# HZ S RI R <z0>" header generated by NanoVNA
sweeps, normalises scientific notation, and serialises reflection coefficient
samples as `[frequency_hz, real, imag]` triples. Metadata about the source file
and reference impedance is also recorded in the output for traceability.

This script intentionally mirrors the parsing performed by
`com.arrl.radiocraft.common.radio.antenna.data.S1pSmith` so the resulting JSON
can be deserialised without precision loss.
"""

from __future__ import annotations

import json
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, List


@dataclass(frozen=True)
class S1pSample:
    freq_hz: float
    real: float
    imag: float


class S1pToJsonConverter:
    """Convert NanoVNA Touchstone files into the mod's JSON profile format."""

    SUPPORTED_HEADER = ("HZ", "S", "RI", "R")

    def convert(self, input_path: Path | str, output_path: Path | str) -> None:
        input_path = Path(input_path)
        output_path = Path(output_path)

        z0, samples = self._read_s1p(input_path)
        payload = {
            "source": input_path.name,
            "z0_ohms": z0,
            "point_count": len(samples),
            "points": [[s.freq_hz, s.real, s.imag] for s in samples],
        }

        output_path.parent.mkdir(parents=True, exist_ok=True)
        with output_path.open("w", encoding="utf-8") as fh:
            json.dump(payload, fh, ensure_ascii=False, indent=2)
            fh.write("\n")

    def _read_s1p(self, path: Path) -> tuple[float, List[S1pSample]]:
        lines = path.read_text(encoding="utf-8").splitlines()
        z0 = 50.0
        samples: List[S1pSample] = []
        saw_header = False

        for raw in lines:
            line = raw.strip()
            if not line or line.startswith("!"):
                continue

            if line.startswith("#"):
                tokens = line[1:].strip().split()
                if len(tokens) < 5:
                    raise ValueError(f"Unsupported header in {path.name}: {line}")
                if tuple(token.upper() for token in tokens[:4]) != self.SUPPORTED_HEADER:
                    raise ValueError(
                        f"Unsupported header modes in {path.name}: {tokens[:4]}"
                    )
                try:
                    z0 = float(tokens[4])
                except ValueError as exc:  # pragma: no cover - defensive
                    raise ValueError(
                        f"Invalid reference impedance in {path.name}: {tokens[4]}"
                    ) from exc
                saw_header = True
                continue

            parts = line.split()
            if len(parts) < 3:
                continue
            freq = float(parts[0].replace("d", "E").replace("D", "E"))
            real = float(parts[1].replace("d", "E").replace("D", "E"))
            imag = float(parts[2].replace("d", "E").replace("D", "E"))
            samples.append(S1pSample(freq_hz=freq, real=real, imag=imag))

        if not saw_header:
            raise ValueError(f"Missing Touchstone header in {path.name}")
        if not samples:
            raise ValueError(f"No data samples found in {path.name}")

        samples.sort(key=lambda s: s.freq_hz)
        return z0, samples


def _main(argv: Iterable[str]) -> int:
    args = list(argv)
    if len(args) != 2:
        print("Usage: python tools/antenna_converter.py <input.s1p> <output.json>")
        return 1

    converter = S1pToJsonConverter()
    converter.convert(args[0], args[1])
    return 0


if __name__ == "__main__":
    sys.exit(_main(sys.argv[1:]))
